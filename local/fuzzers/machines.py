import common
import signal
import os
from script import rs, rss, runscriptq, write_monitor, write_monitor_2, read_monitor
import time

report = common.report
write_socket = common.write_socket
read_socket = common.read_socket

class statistics(object):
    def __init__(self, metrics):
        self.metric_res = metrics
        self.sample_count = 0
        self.to_count = 0
        self.ma_count = 0
        self.last_time_check = time.localtime()

#fuzzer

def always_true(options=None, state=None):
    return True

def fail_check(options, state):
    return not state.failed

def prepare(options, state):
    global signaled
    signaled = False

    #necessary?
    options.log = open("./log-%s-%s-%s" % (options.fuzzbox_name, common.timestamp2(), options.origin), "a")
    report("Starting fuzzer")
    print("[%s] Generic fuzzer" % common.timestamp())

    state.reqScript = ""
    state.status = "RD"

    signal.signal(signal.SIGINT, common.sigkill_handler)

    options.ms = common.prepare_monitor(options.ms_path)
    options.ss = common.prepare_serial(options.ss_path)

    state.stats = statistics(options.metric_res)

def exit_failure(options, state):
    print "Failed"
    print state.failure_reason
    exit()

def create_saved_disk(options, state):
        #create saved disk
    if(options.samples_source == "autogenerated_batch"):
        disk_size = common.calc_disk_size(options) 
        saved_size = disk_size * 10
    if(options.samples_source == "glob"):
        state.samples_list = glob(options.glob_pattern)
        disk_size = 0
        for sample in state.samples_list:
            disk_size += os.stat(sample).st_size
        size_margin  = disk_size * options.samples_size_margin
        disk_size += size_margin
        disk_size += options.settings.SERVER_SIZE
        disk_size = max(int(disk_size), options.settings.MIN_DISK_SIZE)
        saved_size = disk_size * 2 #only one run

    options.disk_size = disk_size
    options.saved_disk_img = common.create_drive(options, size=saved_size, name="%s-saved.raw" % common.timestamp2(), label="saved")
    
def fuzzing_loop(options, state):
    stats = state.stats
    print("Current stats (SA/MA/TO): %d/%d/%d" % (stats.sample_count, stats.ma_count, stats.to_count))

def prepare_disk(options, state):
    if(options.samples_source == "autogenerated_batch"):
        options.tmp_disk_img = common.create_drive(options, size=options.disk_size)
        common.mount_drive(options)
        common.create_layout(options)
        state.samples_list = common.generate(options)
        common.umount_drive(options)
    if(options.samples_source == "glob"):
        options.tmp_disk_img = common.create_drive(options, size=options.disk_size)
        common.mount_drive(options)
        common.create_layout(options)
        for sample in state.samples_list:
            print(options.tmp_mountpoint + "/samples/shared/" + sample)
            os.spawnv(os.P_WAIT, "/bin/cp", ["cp", sample, options.tmp_mountpoint + "/samples/shared/"])
        common.umount_drive(options)

def start_qemu(options, state):
    options.log.write("[%s]\n" % options.tmp_disk_img)
    options.log.flush()
    print("Spawning fuzz for batch: %s" % options.tmp_disk_img)
    common.start(options)
    print("[%s] Started" % common.timestamp())


def proceed(options, state):
    #mount_cdrom(options, options.cdrom)
    read_monitor(options.m)
    options.slot_shared = common.pci_mount(options, options.tmp_disk_img) #hotplug should be completed during bootup
    time.sleep(1)
    options.slot_saved = common.pci_mount(options, options.saved_disk_img) #hotplug should be completed during bootup

    common.proceed1(options)


def init(options, state):
    try:
        common.wait_for_init(options.s)
    except socket.timeout:
        print("Socket timeout, restarting")
        report("Socket timeout, restarting")
        common.write_socket(options.s, "logStop")
        common.del_mountpoint(options)
        common.powerofff(options)
        if(not options.save_disks):
           os.remove(options.tmp_disk_img)
        state.initialized = False
        return
    state.initialized = True

def proceed2(options, state):
    common.proceed2(options)

    common.proceed3(options)

    write_socket(options.s, "logStart e:\\logs\\log-%s-%s.txt" % (options.fuzzbox_name, common.timestamp2()))
    read_socket(options.s)

    if(options.profiling):
        write_socket(options.s, "start_profiling")

    write_socket(options.s, "checkReady")

    state.status = ""
    if(options.wait_key):
        print("Press enter")
        sys.stdin.read(1)

def test(options, state):
    (lastResponse, status, reqScript) = read_socket(options.s)
    state.status = status
    state.lastResponse = lastResponse
    state.reqScript = reqScript
    stats = state.stats

    if(status == "PTO"):
        common.proceed5(options)
        return status
    if(status == "STTO"):
        common.proceed5(options)
        return status
    if(status == "RDTO"):
        common.proceed5(options)
    if(status == "SR"):
        time.sleep(0.2)
        common.execute_script(options, reqScript)
        write_socket(options.s, "")
        return status
    if(status == "RD"):
        sample_path = state.samples_list.pop()
        sample_file = os.path.basename(sample_path)
        test_path = options.settings.prepare_sample(sample_path)
        test_file = os.path.basename(test_path)
        write_socket(options.s, "testFile e:\\samples\\shared\\" + test_file)
        options.settings.runner_0(options, [test_file])
        options.log.write("%s: " % test_file)
        options.log.flush()
        return status
    if(status == "MA" or status == "TO"):
        # react to test end
        common.proceed5(options)
        write_socket(options.s, "")
        options.log.write("[%s] \n" % status)
        options.log.flush()

        if(status == "MA"):
            stats.ma_count += 1
            stats.to_count = 0
        if(status == "TO"):
            stats.to_count += 1
            if(stats.to_count % 3 == 0):
                report("3x TO, settling")
                stats.to_count = 0
                common.settle(options)

        # MA or TO, keep track on sample count
        stats.sample_count += 1
        if(stats.sample_count % stats.metric_res == 0):
            current_time = time.localtime()
            elapsed = time.mktime(current_time) - time.mktime(stats.last_time_check)
            report("Tested: " + str(stats.sample_count))
            report(str(stats.metric_res) + " tested in " + str(elapsed) + " seconds")
            report("Last speed: " + str(stats.metric_res/elapsed) + " tps")
            report("MA count: " + str(state.stats.ma_count))
            stats.to_count = 0
            stats.ma_count = 0
            stats.last_time_check = current_time
            if(options.profiling):
                write_socket(options.s, "dump_stats")

#        if(stats.sample_count % options.settings.restart_count == 0):
#            report("Tested: " + str(stats.sample_count) + ", will restart")
#            restart(options)
#            proceed1(options)
#            accept_con(ss)
    return state.status

def is_init(options, state):
    return state.initialized

def next_test(options, state):
    if(state.status == "CR"):
        return "save"
    else:
        return "test"

def save(options, state):
    write_socket(options.s, "getSynopsis")
    dossier, _, _ = read_socket(s)
    options.log.write("[%s], registered, binned\n" % state.status)
    options.log.flush()
    print("CR in: %s" % options.tmp_disk_img)
    report("CR")
    print("Got crash, restarting")
    report("Got crash, restarting")
    time.sleep(30)

def poweroff(options, state):
    write_socket(options.s, "logStop")
    common.del_mountpoint(options)
    common.powerofff(options)

def shutdown(options, state):
    options.log.close()
    options.s.close()
    common.powerofff(options)
    print("Finished")
    exit()

fuzzer = {
    "name" : "Fuzzer",
    "start" :           { "operation" : prepare,                "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : "create_saved_disk" },
    "create_saved_disk" : { "operation" : create_saved_disk,      "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : "fuzzing_loop" },
    "fuzzing_loop" :    { "operation" : fuzzing_loop,           "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : "prepare_disk" },
    "prepare_disk" :    { "operation" : prepare_disk,           "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : "start_qemu"  },
    "start_qemu" :      { "operation" : start_qemu,             "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : "proceed"  },
    "proceed" :         { "operation" : proceed,                "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : "init" },
    "init" :            { "operation" : init,                   "is_final" : False, "test" : is_init,     "retries" : 0, "failure" : "poweroff",        "next_step" : "proceed2" },
    "proceed2" :        { "operation" : proceed2,               "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : "test" },
    "test" :            { "operation" : test,                   "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : next_test },
    "save" :            { "operation" : save,                   "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : "poweroff" },
    "poweroff" :        { "operation" : poweroff,               "is_final" : False, "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : "start_qemu" },
    "shutdown" :        { "operation" : shutdown,               "is_final" : True,  "test" : fail_check, "retries" : 0, "failure" : "exit_failure",    "next_step" : None },
    "exit_failure" :    { "operation" : exit_failure,           "is_final" : True,  "test" : fail_check, "retries" : 0, "failure" : None,              "next_step" : None }
}

