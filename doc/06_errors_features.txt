[x] 001 - rustock analysis, analysis stopps after 2000000 instructions

Instruction @ 0x6de3ab75 in lib: 

W pamieci sa same ff
Moze kod jakiegos liba zostal zmodyfikowany?
sprobuje rejestrowac ochrone na wszystkie liby
Zaimplementowano
Fixed

--

[x] 002 - obsluga CreateThread
Fixed

--

[x] 003 - cos do dopasowania watkow

IW nie dziala
Wystarczy przeszukanie po adresie, jest zarejestrowany call

--

[n] 004 - TID_00000DFC, blad odczytu

--

[x] 005 - czemu wlasciwy kod jest czasami tak globoko zakopany, np. TID_00000738

Pierwszy adres zarejestrowany w watku to: 0x00401c3b
Wyglada, jakby duza czesc kodu nie zostala nagrana

Pierwszy adres w ogole:
0x002b2505
0x004014c0

Podejrzewam, ze cos jest nie tak z wbudowanymi reakcjami

nie no, ale przeciez reakcje nie wylaczaja skanow!

chyba ze to cos z reakcjami sysnter/sysret
s1/s2 maja za niski priorytet? Proboje podwyzszyc

Cos jest nie tak. nie dzialaja reakcje, ktore powinny dzialac bez problemu.
Pare poprawek w tracerze.

Zaczynajac watek:
ntdll.dll+0x1f01c4

Wlaczenie trasowania przy kazdowazowym uruchomieniu watku

Symbptomem rozwiazania problemu bedzie 0x00401b67 w nagraniu

Ok. Powstaje watek. Jest rejestracja watku, w ktorym jest eip. Dlaczego on (ani nastepny) nie jest strasowany? Tylko dopiero po jakims syscallu

RT,0x00000130,0x00401b67,0x00000000,0x00000000,0x0012f450,0x00000000,0x00000000,0x00000000,0x01cefff0,0x00000200,0x77f064d8,0x00000000,0x0000003b,0x00000023,0x00000023,0x0000001b,0x00000023,0x00000000,0x00000000,0x00000000,0x00000fff,0x00003000,0x7f40f3fd,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cffb00,0x0000ffff,0x00000000,0x00cff300
RT,0x00000130,0x00000000,0x01cefcb8,0x77f064f4,0x77f9714c,0x7ffdf000,0x7ffd3000,0x01cefd00,0x01cefcb8,0x00000246,0x77f064f5,0x00000000,0x0000003b,0x00000023,0x00000023,0x0000001b,0x00000023,0x00000000,0x00000000,0x00000000,0x00000fff,0x00003000,0x7f40f3fd,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cffb00,0x0000ffff,0x00000000,0x00cff300
0x130 0x77f05d3c 96274
0x130 0x77f1b29d 96275

O chuj tu chodzi?

Ok, 0x00401b67 wystepuje w nagraniach.

Teraz trzeba poprawic wyniki analizy struktury :)
Trzeba bylo odblokowac BaseThreadInitThunk :)

--

006 - deploy na vulpix

Maszyny
Procedury
Narzedzia

mount: /dev/loop1 is write-protected, mounting read-only
mount: wrong fs type, bad option, bad superblock on /dev/loop1,
       missing codepage or helper program, or other error

       In some cases useful info is found in syslog - try
       dmesg | tail or so.

po stworzeniu surowego dysku (dd) mozna go podpiac pod winde, zainicjalizowac i sformatowac.
offset takiego dysku odczytujemy:
fdisk -l /home/ish/hs2-data/images/temu-samples-template.bp.2.img * 512

-- 

[x] 007 - conajmniej jeden przyklad niedzialajacej obslugi syscalla:

0x5f4 0x77f064f0 48048
0x5f4 0x77f064f2 48049
RT,0x000005f4,0x00000000,0x00000001,0xffffffff,0x00000000,0x00000000,0x00000000,0x0128ff70,0x0128ff28,0x00000306,0x77f064f5,0x00000000,0x0000003b,0x00000023,0x00000023,0x0000001b,0x00000023,0x00000000,0x00000000,0x00000000,0x00000fff,0x0000e000,0x7f40f3fd,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cffb00,0x0000ffff,0x00000000,0x00cff300
0x5f4 0x77f0589c 48050
0x5f4 0x77eed4f1 48051

s2 zostala wywlaszczona przez t7. To oznacza, ze nie zadzialaly poziomy

Poprawiono.

Czy to jest ok?

ER_3 TID: 0x00000001, Reaction lock is active, continuing, missing reaction s1 (level 0x1) due to lock by s1 (level 0x1)
ER_4 TID: 0x00000600
ER_5 TID1: 0x00000600 instr_count: 3687623


--

[x] 008 - nie zadzialala reakcja CreateFileA

przynajmniej nie ma jej w wynikach
OU nie zostala umieszczona w nagraniu

--

[x] 009 - ogarnac te reakcje. Sa czasem wypisywane pojedynczo, czasem podwojnie, czasem chyba sie nie wykluczaja na tym samym poziomie

Czy reakcje na tym samym poziomie powinny sie wykluczac? Tak.

- Przypadek InternetOpenA i InternetOpenUrlA
Nie sa stworzone reakcje, jest tylko symbol. Wiec reakcje wewnatrz nie sa blokowane.
utworzone reakcje

No wiec:
jeden watek uderza w p4 i wylacza p5. Drugi watek nie uderza w p4, bo jest wylaczaony :(
reakcje musza byc po jednej dla kazdego watku

Moze inaczej:
Procedura uderzenia w breakpoint:
wylaczenie breakpointu -> wlaczenie jakiejs flagi -> wykonanie 1 instrukcji -> wlaczenie breakpointu -> wylaczenie flagi

To moze rozwiazac kilka problemow:
ze wykonanie poszlo inna sciezka i wlaczajacy bp nie zostal uderzony
Nie edzie potrzeba sprzegania breakpointow

- przypadek InternetSetOptionA
Sa ustawione reakcje puste (0x100). Nie sa ekskluzywne. Sprawdzic, czy cos sie zmieni po ustawieniu jako ekskluzywne.
Nowe nagranie (rustock_004_2) z okreslonyim reakcjami

- przypadek HttpQueryInfoA
Nie jest zarejestrowana zadna reakcja
Zarejestrowano reakcje

- przypadek InternetReadFile
Zarejestrowane reakcje puste
Zarejestrowano poprawne reakcje

- przypadek CreateFileA
Sa zarejestrowane zwykle reakcje. Wyglada na to, ze kazda z reakcji zostala wykonana 2 razy.
OU jest tylko 1 raz, wiec blad znajduje sie w taint

--

[x] 010 - rejestrowanie jmpow

Minimalizowac wypisywanie jmpow w oparciu o tabelki z juz zarejestrowanymi. Ale sa potrzebne do informowania o mozliwych rozgalezieniach.

--

[x] 011 - o co chodzi z tym ostatnim zamieszaniem z C3?

--

[x] 012 - zaimplementowac kopiowanie plikow (do kopiowania dropow i jebanych logow)

--

[x] 013 - zaimplementowac obsluge przerwania analizy

Moze zerwac polaczenie z internalem i nawiazac od nowa, a nastepnie przejsc do obslugi przerwania?
Brzydkie, do uporzadkowania pozniej :)


--

[x] 014 - uporzadkowanie przerwan

M.in. kazdy watek powinien miec swoja kolejke
Powinien tez byc ladnie obsluzone zabijamie qemu
Powinno dzialac na ctrl-c

Nalezy nie dopuscic do przelania ctrl-c do podprocesu.

Probowalem:

import signal

def preexec_function():
    signal.signal(signal.SIGINT, signal.SIG_IGN)

w argumencie preexec_fn Popen

a moze raczej isc w strone ignorowania sigint? Tak, to wyglada na sluszna sciezke
Nie, udalo mi sie ignorowac w podprocesach za pomoca: os.setpgrp()
Teraz tylko umozliwic wylaczanie przez monitor
Dziala :)

--

[x] 015 - reenabling breakpointow

[x] Zweryfikowac, czy dziala 
Jesli dziala, oznacza to, ze koncepcja powiazanych reakcji w przypadku hookow bedzie nieaktualna. Reakcje koncowe hooka beda dzialac bez powiazan. Mozna to sprawdzic likwidujac powiazania i poszerzajac liste root reakcji.

Czy zliczanie reakcji ma w tej sytuacji sens?
Ma sens, poniewaz sluzy wykluczaniu reakcji pomiedzy nimi.

--

[x] 016 - podwojne komentarze po nagrywaniu

rzeczywiscie, druga z powiazanych reakcji czesto jest obslugiwana, kiedy powinna byc zablokowana. Blad nastepuje w nagrywaniu

Przyklad: 23146862 - HttpQueryInfoA (q2) 
nie powinno byc zadnej reakcji az do q3 - 23147327

Tymczasem:
23147327 - m2
23147327 - m3
itd.

Przy pierwszej (m2) twierdzi, ze nie ma locking

Do sprawdzenia: 
czy nie jest za bardzo zwiekszany reaction_count dla bp.
czy after_unlocking jest dobrze obslugiwane?

Przyklad2:

40100090 - m4
40101201 - m5

Powodem bylo nieoznaczenie reakcji skojarzonej z ekskluzywna jako ekskluzywna. W wyniku tego nie przeprowadzano zerowania after_unlock. 

Bledow jest mniej, ale nadal wystepuja (watki: 4c8, b8, 5e8, 5f8, 79c)

watek b8:

p4 (1740065) nie wykonano w wyniku blokady przez s0 (1735479)
W sumie nalezy sobie zadac pytanie dlaczego tak nie ma w innych watkach, poniewaz s0 powinno zablokowac wszystkie reakcje.
Nalezy wylaczyc ekskluzywnosc s0/s1
Reakcje s0/s1 powinny miec wyzszy priorytet, zeby zarejestrowac WSZYSTKIE modyfikacje contextow i pamieci. Ale nie powinny byc ekskluzywne, bo to przeszkadza w rejestrowaniu nowych watkow. Poza tym czesto moga byc rekurencyjne, co moze spowodowac problemy z tym sparowaniem.

Rozwiazanie alternatywne: podtrzymac ekskluzywnosc i zasymulowac uderzenie w s1 w kodzie ntdll.dll przed rozpoczeciem watku - np. w 0x77e31172 (ntdll.dll + 0x51172)

Zadzialalo pierwsze :)

--

017 - obsluga regionow wedlug nowego algorytmu

--

[x] 018 - bledy w reakcjach po analizie cleopatra_1

LoadLibrary - ekskluzywny lock jest wylaczany przez rekurencje
Rozwiazanie: przy otwieraniu zamiast zwyklej jedynki - dodawanie, przy zamykaniu - -1. Jak semafor

--

[x] 019 - zoptymalizowac tracer / zrodlo niewydajnosci przy nagrywaniu cleopatra (okolice 10-15M instrukcji)

Nie za bardzo sie da... ss_callback jest juz niemal optymalne. Jedyne co to brak czekania na mutex albo pisanie do buffera.
Po usunieciu reakcji z nowymi rutynami wrocilo do normy :/

Odpowiedzialna jest reakcja q6
Poprawiono rekacje na adresy w kernelbase zamiast kernel i dziala

--

020 - dokladne logowanie z kazdego komponentu

--

021 - zaimplementuj skoki w extended

--


