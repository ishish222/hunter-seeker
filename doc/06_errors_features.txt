[x] 001 - rustock analysis, analysis stopps after 2000000 instructions

Instruction @ 0x6de3ab75 in lib: 

W pamieci sa same ff
Moze kod jakiegos liba zostal zmodyfikowany?
sprobuje rejestrowac ochrone na wszystkie liby
Zaimplementowano
Fixed

--

[x] 002 - obsluga CreateThread
Fixed

--

[x] 003 - cos do dopasowania watkow

IW nie dziala
Wystarczy przeszukanie po adresie, jest zarejestrowany call

--

[n] 004 - TID_00000DFC, blad odczytu

--

[x] 005 - czemu wlasciwy kod jest czasami tak globoko zakopany, np. TID_00000738

Pierwszy adres zarejestrowany w watku to: 0x00401c3b
Wyglada, jakby duza czesc kodu nie zostala nagrana

Pierwszy adres w ogole:
0x002b2505
0x004014c0

Podejrzewam, ze cos jest nie tak z wbudowanymi reakcjami

nie no, ale przeciez reakcje nie wylaczaja skanow!

chyba ze to cos z reakcjami sysnter/sysret
s1/s2 maja za niski priorytet? Proboje podwyzszyc

Cos jest nie tak. nie dzialaja reakcje, ktore powinny dzialac bez problemu.
Pare poprawek w tracerze.

Zaczynajac watek:
ntdll.dll+0x1f01c4

Wlaczenie trasowania przy kazdowazowym uruchomieniu watku

Symbptomem rozwiazania problemu bedzie 0x00401b67 w nagraniu

Ok. Powstaje watek. Jest rejestracja watku, w ktorym jest eip. Dlaczego on (ani nastepny) nie jest strasowany? Tylko dopiero po jakims syscallu

RT,0x00000130,0x00401b67,0x00000000,0x00000000,0x0012f450,0x00000000,0x00000000,0x00000000,0x01cefff0,0x00000200,0x77f064d8,0x00000000,0x0000003b,0x00000023,0x00000023,0x0000001b,0x00000023,0x00000000,0x00000000,0x00000000,0x00000fff,0x00003000,0x7f40f3fd,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cffb00,0x0000ffff,0x00000000,0x00cff300
RT,0x00000130,0x00000000,0x01cefcb8,0x77f064f4,0x77f9714c,0x7ffdf000,0x7ffd3000,0x01cefd00,0x01cefcb8,0x00000246,0x77f064f5,0x00000000,0x0000003b,0x00000023,0x00000023,0x0000001b,0x00000023,0x00000000,0x00000000,0x00000000,0x00000fff,0x00003000,0x7f40f3fd,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cffb00,0x0000ffff,0x00000000,0x00cff300
0x130 0x77f05d3c 96274
0x130 0x77f1b29d 96275

O chuj tu chodzi?

Ok, 0x00401b67 wystepuje w nagraniach.

Teraz trzeba poprawic wyniki analizy struktury :)
Trzeba bylo odblokowac BaseThreadInitThunk :)

--

006 - deploy na vulpix

Maszyny
Procedury
Narzedzia

mount: /dev/loop1 is write-protected, mounting read-only
mount: wrong fs type, bad option, bad superblock on /dev/loop1,
       missing codepage or helper program, or other error

       In some cases useful info is found in syslog - try
       dmesg | tail or so.

po stworzeniu surowego dysku (dd) mozna go podpiac pod winde, zainicjalizowac i sformatowac.
offset takiego dysku odczytujemy:
fdisk -l /home/ish/hs2-data/images/temu-samples-template.bp.2.img * 512

-- 

[x] 007 - conajmniej jeden przyklad niedzialajacej obslugi syscalla:

0x5f4 0x77f064f0 48048
0x5f4 0x77f064f2 48049
RT,0x000005f4,0x00000000,0x00000001,0xffffffff,0x00000000,0x00000000,0x00000000,0x0128ff70,0x0128ff28,0x00000306,0x77f064f5,0x00000000,0x0000003b,0x00000023,0x00000023,0x0000001b,0x00000023,0x00000000,0x00000000,0x00000000,0x00000fff,0x0000e000,0x7f40f3fd,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cff300,0x0000ffff,0x00000000,0x00cffb00,0x0000ffff,0x00000000,0x00cff300
0x5f4 0x77f0589c 48050
0x5f4 0x77eed4f1 48051

s2 zostala wywlaszczona przez t7. To oznacza, ze nie zadzialaly poziomy

Poprawiono.

Czy to jest ok?

ER_3 TID: 0x00000001, Reaction lock is active, continuing, missing reaction s1 (level 0x1) due to lock by s1 (level 0x1)
ER_4 TID: 0x00000600
ER_5 TID1: 0x00000600 instr_count: 3687623


--

[x] 008 - nie zadzialala reakcja CreateFileA

przynajmniej nie ma jej w wynikach
OU nie zostala umieszczona w nagraniu

--

[x] 009 - ogarnac te reakcje. Sa czasem wypisywane pojedynczo, czasem podwojnie, czasem chyba sie nie wykluczaja na tym samym poziomie

Czy reakcje na tym samym poziomie powinny sie wykluczac? Tak.

- Przypadek InternetOpenA i InternetOpenUrlA
Nie sa stworzone reakcje, jest tylko symbol. Wiec reakcje wewnatrz nie sa blokowane.
utworzone reakcje

No wiec:
jeden watek uderza w p4 i wylacza p5. Drugi watek nie uderza w p4, bo jest wylaczaony :(
reakcje musza byc po jednej dla kazdego watku

Moze inaczej:
Procedura uderzenia w breakpoint:
wylaczenie breakpointu -> wlaczenie jakiejs flagi -> wykonanie 1 instrukcji -> wlaczenie breakpointu -> wylaczenie flagi

To moze rozwiazac kilka problemow:
ze wykonanie poszlo inna sciezka i wlaczajacy bp nie zostal uderzony
Nie edzie potrzeba sprzegania breakpointow

- przypadek InternetSetOptionA
Sa ustawione reakcje puste (0x100). Nie sa ekskluzywne. Sprawdzic, czy cos sie zmieni po ustawieniu jako ekskluzywne.
Nowe nagranie (rustock_004_2) z okreslonyim reakcjami

- przypadek HttpQueryInfoA
Nie jest zarejestrowana zadna reakcja
Zarejestrowano reakcje

- przypadek InternetReadFile
Zarejestrowane reakcje puste
Zarejestrowano poprawne reakcje

- przypadek CreateFileA
Sa zarejestrowane zwykle reakcje. Wyglada na to, ze kazda z reakcji zostala wykonana 2 razy.
OU jest tylko 1 raz, wiec blad znajduje sie w taint

--

[x] 010 - rejestrowanie jmpow

Minimalizowac wypisywanie jmpow w oparciu o tabelki z juz zarejestrowanymi. Ale sa potrzebne do informowania o mozliwych rozgalezieniach.

--

[x] 011 - o co chodzi z tym ostatnim zamieszaniem z C3?

--

[x] 012 - zaimplementowac kopiowanie plikow (do kopiowania dropow i jebanych logow)

--

[x] 013 - zaimplementowac obsluge przerwania analizy

Moze zerwac polaczenie z internalem i nawiazac od nowa, a nastepnie przejsc do obslugi przerwania?
Brzydkie, do uporzadkowania pozniej :)


--

[x] 014 - uporzadkowanie przerwan

M.in. kazdy watek powinien miec swoja kolejke
Powinien tez byc ladnie obsluzone zabijamie qemu
Powinno dzialac na ctrl-c

Nalezy nie dopuscic do przelania ctrl-c do podprocesu.

Probowalem:

import signal

def preexec_function():
    signal.signal(signal.SIGINT, signal.SIG_IGN)

w argumencie preexec_fn Popen

a moze raczej isc w strone ignorowania sigint? Tak, to wyglada na sluszna sciezke
Nie, udalo mi sie ignorowac w podprocesach za pomoca: os.setpgrp()
Teraz tylko umozliwic wylaczanie przez monitor
Dziala :)

--

[x] 015 - reenabling breakpointow

[x] Zweryfikowac, czy dziala 
Jesli dziala, oznacza to, ze koncepcja powiazanych reakcji w przypadku hookow bedzie nieaktualna. Reakcje koncowe hooka beda dzialac bez powiazan. Mozna to sprawdzic likwidujac powiazania i poszerzajac liste root reakcji.

Czy zliczanie reakcji ma w tej sytuacji sens?
Ma sens, poniewaz sluzy wykluczaniu reakcji pomiedzy nimi.

--

[x] 016 - podwojne komentarze po nagrywaniu

rzeczywiscie, druga z powiazanych reakcji czesto jest obslugiwana, kiedy powinna byc zablokowana. Blad nastepuje w nagrywaniu

Przyklad: 23146862 - HttpQueryInfoA (q2) 
nie powinno byc zadnej reakcji az do q3 - 23147327

Tymczasem:
23147327 - m2
23147327 - m3
itd.

Przy pierwszej (m2) twierdzi, ze nie ma locking

Do sprawdzenia: 
czy nie jest za bardzo zwiekszany reaction_count dla bp.
czy after_unlocking jest dobrze obslugiwane?

Przyklad2:

40100090 - m4
40101201 - m5

Powodem bylo nieoznaczenie reakcji skojarzonej z ekskluzywna jako ekskluzywna. W wyniku tego nie przeprowadzano zerowania after_unlock. 

Bledow jest mniej, ale nadal wystepuja (watki: 4c8, b8, 5e8, 5f8, 79c)

watek b8:

p4 (1740065) nie wykonano w wyniku blokady przez s0 (1735479)
W sumie nalezy sobie zadac pytanie dlaczego tak nie ma w innych watkach, poniewaz s0 powinno zablokowac wszystkie reakcje.
Nalezy wylaczyc ekskluzywnosc s0/s1
Reakcje s0/s1 powinny miec wyzszy priorytet, zeby zarejestrowac WSZYSTKIE modyfikacje contextow i pamieci. Ale nie powinny byc ekskluzywne, bo to przeszkadza w rejestrowaniu nowych watkow. Poza tym czesto moga byc rekurencyjne, co moze spowodowac problemy z tym sparowaniem.

Rozwiazanie alternatywne: podtrzymac ekskluzywnosc i zasymulowac uderzenie w s1 w kodzie ntdll.dll przed rozpoczeciem watku - np. w 0x77e31172 (ntdll.dll + 0x51172)

Zadzialalo pierwsze :)

--

017 - obsluga regionow wedlug nowego algorytmu

--

[x] 018 - bledy w reakcjach po analizie cleopatra_1

LoadLibrary - ekskluzywny lock jest wylaczany przez rekurencje
Rozwiazanie: przy otwieraniu zamiast zwyklej jedynki - dodawanie, przy zamykaniu - -1. Jak semafor

--

[x] 019 - zoptymalizowac tracer / zrodlo niewydajnosci przy nagrywaniu cleopatra (okolice 10-15M instrukcji)

Nie za bardzo sie da... ss_callback jest juz niemal optymalne. Jedyne co to brak czekania na mutex albo pisanie do buffera.
Po usunieciu reakcji z nowymi rutynami wrocilo do normy :/

Odpowiedzialna jest reakcja q6
Poprawiono rekacje na adresy w kernelbase zamiast kernel i dziala

--

020 - dokladne logowanie z kazdego komponentu

--

[x] 021 - zaimplementuj skoki w extended

--

[x] 022 - zadawanie argumentow do binarki

--

[x] 023 - obsluz przerwania w ciagu wykonywania podskryptu

--

[x] 024 - ss_callback tylko po ST

Bo analiza dlugo trwa
Ale mozliwe, ze beda zaklocenia w nagrywaniu watkow. Trzeba przeprowadzic testy regresyjne z rustockiem.

Dodalem warunek, jest duzo szybciej.

No niby sa inne watki od poczatku, ale w 0x778 konczy sie nagranie na CreateFileA

To dlatego, ze analize zaczales w trakcie nagrywania, helou! :) Wszystko dziala

--

027 - zaimplementowac podgrywanie wybranego pliku w momencie CreateFileA

--

028 - zaimplementowac podgrywanie wybranego pliku w momencie InternetReadFile 

przez wskazanie pliku responderowi
Nie chce sie skopiowac :/
Moze nie da sie skopiowac z cmd ukrytego lub  zukrytego folderu? <sighs>

--

[x] 029 - zaimplementowac wykrywanie switch-case (jmp do tablicy)

--

[x] 030 - zaimplementowac pisanie do rejestrow

Jest blad przy zapisywaniu contextu, 0x6 - bad handle
Wybiera 0x0 jago TID.
Zaimplementowano ze domyslnie jest id = -1, co oznacza, ze brany pod uwage jest aktualny watek. Ewentualnie mozliwe, ze potrzebne bedzie wskazanie innego watku w oddzielnych rutynach klasy Tracer.

--

031 - zeby komunikaty sie nie przeslanialy (np. o jmpie i reakcji)

--

[x] 032 - nazwy reakcji dluzsze niz 2 znaki

Implementacja zmian w tracer + testy z nowymi skryptami

--

[x] 033 - bledy zwiazane z poszerzeniem nazw reakcji

- nie dzialaja Decision
zmiany w tracing_parts.decision

--

[x] 034 - zczytywanie argumentow z kilku linii

Zaimplementowano w fuzzer.py

--

[x] 035 - zapetla sie BP START

zastapilem wycinanie spacji strip()
uderza caly czas w ST :/
usunieto ss_callback przy ET. Ale czy to rozwiaze problem?
Czemu ten problem nie wystepowal wczesniej?

Do przeprowadzenia testy z innym bptem.
Testy zakonczone powodzeniem.

--

037 - zaimplementowac samowstawiajacy breakpoint jako opcja xx:xx

--

[x] 038 - brak switch/case w wyniku analizy

odczytuje jako 0xcc :/
problem z tracerem, ktory wynotowuje bajt zanim nastapi usuniecie bp.

Nie! Problem z postawieniem bp PRZED MemoryDump!!!

--

[x] 039 - analiza wysypuje sie w przypadku usuniecia pliku w LF

dodano obsluge

--

[x] 040 - dodac beeep jako mozliwe polecenie

--

[x] 041 - dodac wypisanie do komentarzy jako polecenie

--

[x] 042 - ogarnij ustawianie parametrow binarki

--

[x] 043 - blad w cleopatra_1_014:91020080

w nagraniu jest numer, pod ktorym jest call.

W analizie zrodlem calla jest inny adres :/
pod 0x4083d0 jest 0xff :/
czyzby ten obszar nie byl chroniony??
Zabraklo SecureAllSections :(

--

044 - moze system ostrzezen o braku pewnych instrukcji w skrypcie

--

[x] 045 - kopiowanie logow do indywidualnych katalogow

--

[x] 046 - powazny problem z breakpointami. Z jakiegos powodu stare skrypty nie dzialaja dobrze. Nie dzialaja ciagi reakcji do obslugi dekrypterow

Trzeba gruntownie przeanalizowac sposob dodawania i obslugi reakcji i breakpointow.
Problem: co jesli update_breakpoint wykonamy na EAX+0x200, podczas gdy EAX=0x2?

To moze miec zwiazek z autorepeatem dla breakpointow. Nalezy chyba wprowadzic konwencje xx:xx do autorepeatu.

